// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct Image: Codable {
    public var imageID: Int
    public var encoded: String
    public var dateCreated: Date?

    public init(imageID: Int, encoded: String, dateCreated: Date? = nil) {
        self.imageID = imageID
        self.encoded = encoded
        self.dateCreated = dateCreated
    }

    private enum CodingKeys: String, CodingKey {
        case imageID = "image_id"
        case encoded
        case dateCreated = "date_created"
    }
}

public struct CreateImages: Codable {
    public var images: [CreateImage]?

    public init(images: [CreateImage]? = nil) {
        self.images = images
    }
}

public struct CreateImage: Codable {
    public var dateCreated: Date?
    public var encoded: String

    public init(dateCreated: Date? = nil, encoded: String) {
        self.dateCreated = dateCreated
        self.encoded = encoded
    }

    private enum CodingKeys: String, CodingKey {
        case dateCreated = "date_created"
        case encoded
    }
}

public struct HTTPValidationError: Codable {
    public var detail: [ValidationError]?

    public init(detail: [ValidationError]? = nil) {
        self.detail = detail
    }
}

public struct ValidationError: Codable {
    /// Error Type
    public var type: String
    /// Location
    public var loc: [LocItem]
    /// Message
    public var msg: String

    public struct LocItem: Codable {
        public var string: String?
        public var int: Int?

        public init(string: String? = nil, int: Int? = nil) {
            self.string = string
            self.int = int
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.string = try? container.decode(String.self)
            self.int = try? container.decode(Int.self)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            if let value = string { try container.encode(value) }
            if let value = int { try container.encode(value) }
        }
    }

    public init(type: String, loc: [LocItem], msg: String) {
        self.type = type
        self.loc = loc
        self.msg = msg
    }
}

public struct CreateAndUpdateCapture: Codable {
    public var dateUpdated: Date?
    public var images: [CreateImage]?
    public var coordinates: String?
    public var dateCreated: Date?
    public var annotation: String

    public init(dateUpdated: Date? = nil, images: [CreateImage]? = nil, coordinates: String? = nil, dateCreated: Date? = nil, annotation: String) {
        self.dateUpdated = dateUpdated
        self.images = images
        self.coordinates = coordinates
        self.dateCreated = dateCreated
        self.annotation = annotation
    }

    private enum CodingKeys: String, CodingKey {
        case dateUpdated = "date_updated"
        case images
        case coordinates
        case dateCreated = "date_created"
        case annotation
    }
}

public struct DeleteImages: Codable {
    public var imageIDs: [Int]

    public init(imageIDs: [Int]) {
        self.imageIDs = imageIDs
    }

    private enum CodingKeys: String, CodingKey {
        case imageIDs = "image_ids"
    }
}

public struct Captures: Codable {
    public var captures: [Capture]

    public init(captures: [Capture]) {
        self.captures = captures
    }
}

public struct Capture: Codable {
    public var annotation: String
    public var dateCreated: Date?
    public var captureID: Int
    public var images: [Image]?
    public var coordinates: String?
    public var dateUpdated: Date?

    public init(annotation: String, dateCreated: Date? = nil, captureID: Int, images: [Image]? = nil, coordinates: String? = nil, dateUpdated: Date? = nil) {
        self.annotation = annotation
        self.dateCreated = dateCreated
        self.captureID = captureID
        self.images = images
        self.coordinates = coordinates
        self.dateUpdated = dateUpdated
    }

    private enum CodingKeys: String, CodingKey {
        case annotation
        case dateCreated = "date_created"
        case captureID = "capture_id"
        case images
        case coordinates
        case dateUpdated = "date_updated"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
